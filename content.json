[{"title":"javascript实现继承的几种思路","date":"2017-05-24T02:55:50.977Z","path":"2017/05/24/js_inherit/","text":"本文主要总结一下js实现继承的几种思路。我们知道，在ES6之前，javascript是没有类的概念的，想要实现继承，主要是依靠原型链来模拟实现的。 进入正文前先了解下以下知识： 每个构造函数(constructor)都有一个原型对象(prototype),原型对象都包含一个指向构造函数的指针,而实例(instance)都包含一个指向原型对象的内部指针. 如果试图引用对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性. 搜索轨迹: instance –&gt; constructor.prototype…–&gt;Object.prototype 1).首先会在instance内部属性中找一遍; 2).接着会在instance.proto(constructor.prototype)中寻找直至Object的原型对象 这种搜索轨迹,形似一条长链, 又因prototype在这个搜索过程中充当链接的作用,于是我们把这种实例与原型的链条称作 原型链 . 类式继承123456789101112131415161718192021222324252627function Animal (color) &#123; this.name = 'animal'; this.type = ['dog','cat']; this.color = color;&#125;Animal.prototype.greet = function (sound) &#123; console.log(sound);&#125;function Cat () &#123; this.name = 'cat';&#125;//在实例化一个类时，新创建的对象复制了父类的构造函数内的属性与方法并且将原型__proto__指向了父类的原型对象，这样就拥有了父类的原型对象上的属性与方法。Cat.prototype = new Animal('白色');var cat = new Cat();cat.greet('喵喵');console.log(cat.type);//类式继承方式缺点//引用缺陷cat.type.push('bird');var cat2 = new Cat();console.log(cat2.type);//无法为不同的实例初始化继承来的属性console.log(cat.color); // \"白色\"console.log(cat2.color); // \"白色\" 构造函数继承 基本思路:即在子类型构造函数的内部调用超类型构造函数. 123456789101112131415161718192021222324252627282930313233343536/** * 构造函数继承方式可以避免类式继承的缺陷 * 其一, 保证了原型链中引用类型值的独立,不再被所有实例共享; * 其二, 子类型创建时也能够向父类型传递参数. */// 声明父类function Animal(color) &#123; this.name = 'animal'; this.type = ['dog','cat']; this.color = color;&#125;// 添加共有方法Animal.prototype.greet = function(sound) &#123; console.log(sound);&#125;// 声明子类function Cat(color) &#123; Animal.apply(this, arguments);&#125;var cat = new Cat('白色');var cat2 = new Cat('黑色');cat.type.push('bird');console.log(cat.color); // \"白色\"console.log(cat.type); // [\"dog\", \"cat\", \"bird\"]console.log(cat2.type); // [\"dog\", \"cat\"]console.log(cat2.color); // \"黑色\"//构造函数继承也是有缺陷的，那就是方法都在构造函数中定义, 因此函数复用也就不可用了,//对于子类而言，我们也无法获取到父类的共有方法，也就是通过原型prototype绑定的方法：//cat.greet(); // Uncaught TypeError: cat.greet is not a function 组合继承 基本思路: 使用原型链实现对原型属性和方法的继承,通过借用构造函数来实现对实例属性的继承. 这样,既通过在原型上定义方法实现了函数复用,又能保证每个实例都有它自己的属性. 123456789101112131415161718192021222324252627282930313233// 声明父类 function Animal(color) &#123; this.name = 'animal'; this.type = ['dog','cat']; this.color = color; &#125; // 添加共有方法 Animal.prototype.greet = function(sound) &#123; console.log(sound); &#125; // 声明子类 function Cat(color) &#123; // 构造函数继承 Animal.apply(this, arguments); &#125; // 类式继承cat.prototype = new Animal(); var cat = new Cat('白色'); var cat2 = new Cat('黑色'); cat.type.push('bird'); console.log(cat.color); // \"白色\"console.log(cat.type); // [\"dog\", \"cat\", \"bird\"]console.log(cat2.type); // [\"dog\", \"cat\"]console.log(cat2.color); // \"黑色\"Cat.greet('喵喵'); // \"喵喵\"//组合继承最大的问题就是无论什么情况下,都会调用两次父类构造函数: 一次是在创建子类型原型的时候, 另一次是在子类型构造函数内部. 寄生组合继承1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//寄生组合式继承强化的部分就是在组合继承的基础上减少一次多余的调用父类的构造函数： function Animal(color) &#123; this.color = color; this.name = 'animal'; this.type = ['dog', 'cat'];&#125;Animal.prototype.greet = function(sound) &#123; console.log(sound);&#125;function Cat(color) &#123; Animal.apply(this, arguments); this.name = 'cat';&#125;//如果不支持Object.create方法则模拟实现Object.create方法/*if (!Object.create) &#123; Object.prototype.create = function (proto) &#123; function F() &#123;&#125; F.prototype = proto; return new F(); &#125;&#125;*//* 注意下面两行 *///使用Object.create()进行一次浅拷贝，将父类原型上的方法拷贝后赋给Cat.prototype，这样子类上就能拥有了父类的共有方法，而且少了一次调用父类的构造函数Cat.prototype = Object.create(Animal.prototype);//由于对Animal的原型进行了拷贝后赋给Cat.prototype，因此Cat.prototype上的constructor属性也被重写了，所以我们要修复这一个问题Cat.prototype.constructor = Cat;Cat.prototype.getName = function() &#123; console.log(this.name);&#125;var cat = new Cat('白色'); var cat2 = new Cat('黑色'); cat.type.push('bird'); console.log(cat.color); // \"白色\"console.log(cat.type); // [\"dog\", \"cat\", \"bird\"]console.log(cat2.type); // [\"dog\", \"cat\"]console.log(cat2.color); // \"黑色\"cat.greet('喵喵'); // \"喵喵\" es6实现继承123456789101112131415161718192021222324class Animals &#123; constructor(color) &#123; this.color = color; &#125; greet(sound) &#123; console.log(sound); &#125; &#125; class Cats extends Animals &#123; constructor(color) &#123; /** * 子类必须在constructor方法中调用super方法，否则新建实例时会报错。 * 这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。 * 如果不调用super方法，子类就得不到this对象 */ super(color); this.color = color; &#125; &#125; let cats = new Cats('黑色'); cats.greet('喵喵'); // \"喵喵\"console.log(cats.color); // \"黑色\" 以上就是javascript实现继承的几种思路，其中最常用的就是寄生组合继承了，而es6实现的继承最为简洁方便，不得不说es6大法好啊。本文如果描述有误，欢迎到 issues 交流，本人会及时修正。","tags":[{"name":"javascript","slug":"javascript","permalink":"chenxiaohuan.github.io/tags/javascript/"}]},{"title":"快速了解Sass","date":"2017-05-03T03:59:51.842Z","path":"2017/05/03/Sass/","text":"Sass是什么？ sass（[sæs]）英文全称为Syntactically Awesome StyleSheets， 是一款强化 CSS 的辅助工具，它在 CSS 语法的基础上增加了变量 (variables)、嵌套 (nested rules)、混合 (mixins)、导入 (inline imports) 等高级功能，这些拓展令 CSS 更加强大与优雅。使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。sass是采用的Ruby语言编写的一款有着缩进式风格的css预处理语言，从第三代开始，放弃了缩进式风格，并且完全向下兼容普通的css代码，这一代的sass也被称为scss 。 安装教程参考下面的地址： https://www.sass.hk/install/ 常用语法1、变量 sass使用$符号来标识变量。任何可以用作css属性值的赋值都 可以用作sass的变量值，甚至是以空格分割的多个属性值，或以逗号分割的多个属性值。与CSS属性不同，变量可以在css规则块定义之外存在。当变量定义在css规则块内，那么该变量只能在此规则块内使用。 12345678910111213141516171819202122$basic-color: #333;body &#123; color: $basic-color;&#125;nav &#123; $width: 1200px; width: $width;&#125;.color-default &#123; color: $basic-color;&#125;//编译后body &#123; color: #333;&#125;nav &#123; width: 1200px;&#125;.color-default &#123; color: #333;&#125; 2、嵌套规则 (Nested Rules) 1234567#content &#123; article &#123; h1 &#123; color: #333 &#125; p &#123; margin-bottom: 1.4em &#125; &#125; aside &#123; background-color: #EEE &#125;&#125; 1234 /* 编译后 */#content article h1 &#123; color: #333 &#125;#content article p &#123; margin-bottom: 1.4em &#125;#content aside &#123; background-color: #EEE &#125; 父选择器 &amp; (Referencing Parent Selectors: &amp;) 在嵌套 CSS 规则时，有时也需要直接使用嵌套外层的父选择器，例如，当给某个元素设定 hover 样式时，或者当 body 元素有某个 classname 时，可以用 &amp; 代表嵌套规则外层的父选择器。编译后的 CSS 文件中 &amp; 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递。&amp; 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器。 1234article a &#123; color: blue; &amp;:hover &#123; color: red &#125;&#125; 123/* 编译后 */article a &#123; color: blue &#125;article a:hover &#123; color: red &#125; 群组选择器的嵌套 123nav, aside &#123; a &#123;color: blue&#125;&#125; 12/* 编译后 */nav a, aside a &#123;color: blue&#125; 子组合选择器和同层组合选择器：&gt;、+和~ 123456789article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125; 123456/* 编译后 */article ~ article &#123; border-top: 1px dashed #ccc &#125;article &gt; section &#123; background: #eee &#125;article dl &gt; dt &#123; color: #333 &#125;article dl &gt; dd &#123; color: #555 &#125;nav + article &#123; margin-top: 0 &#125; 属性嵌套 (Nested Properties) 有些 CSS 属性遵循相同的命名空间 (namespace)，比如 font-family, font-size, font-weight 都以 font 作为属性的命名空间。为了便于管理这样的属性，同时也为了避免了重复输入，Sass 允许将属性嵌套在命名空间中。 1234567891011121314nav &#123; border: &#123; style: solid; width: 1px; color: #ccc; &#125;&#125;.nav &#123; border: 1px solid #ccc &#123; left: 0px; right: 0px; &#125;&#125; 123456789101112/* 编译后 */nav &#123; border-style: solid; border-width: 1px; border-color: #ccc;&#125;.nav &#123; border: 1px solid #ccc; border-left: 0px; border-right: 0px;&#125; 3、@import,导入SASS文件 1@import \"reset.scss\"; 4、注释 / / 与 // (Comments: / / and //) Sass 支持标准的 CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会。 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 5、 混合器 混合器使用@mixin标识符定义。通常用于把样式中的通用样式抽离出来，然后轻松地在其他地方重用。 @include调用会把混合器中的所有样式提取出来放在@include被调用的地方。 从易读性和可维护性方面来说，语义化的命名混合器能让你避免重复使用混合器，可以很容易地在样式表的不同地方共享样式。 1234567891011@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125;.notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125; 12345678/* 编译后 */.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 6、@extend，选择器继承 选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式。这个通过@extend语法实现。 使用@extend的选择器不仅会继承被继承选择器自身的所有样式，任何跟被继承选择器有关的组合选择器样式也会被使用@extend的选择器以组合选择器的形式继承。 123456789101112131415.error &#123; border: 1px red; background-color: #fdd;&#125;.error a&#123; color: red; font-weight: 100;&#125;h1.error &#123; font-size: 1.2rem;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 123456789101112131415/* 编译后 */.error, .seriousError &#123; border: 1px red; background-color: #fdd;&#125;.error a, .seriousError a &#123; color: red; font-weight: 100;&#125;h1.error, h1.seriousError &#123; font-size: 1.2rem;&#125;.seriousError &#123; border-width: 3px;&#125; 本文简单的介绍了下本人常用的Sass语法，其他如运算和一些指令等，因篇幅有限就不再介绍，如果想了解更多Sass相关语法，可到官方文档查看。感谢您花费时间浏览本文，如果本文有错误如错别字或者描述不当，请到 issues 指出，本人会及时修正，如果有什么更好的建议也欢迎各位提出。 更多Sass语法查看：https://www.sass.hk/docs/","tags":[{"name":"css","slug":"css","permalink":"chenxiaohuan.github.io/tags/css/"}]},{"title":"es6之关键字let","date":"2017-04-25T08:14:07.710Z","path":"2017/04/25/es6-let-command/","text":"前文：在前面闭包一文有提到： 假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类推。 我们用闭包实现了这个效果，同时我们提到了可以使用es6的let命令实现一样的效果。所以本文将介绍一下es6的let命令。 什么是let命令let命令是ES6新增的关键字，它用来声明变量。用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let num1 = 0; var num2 = 1;&#125;num1 // ReferenceError: num1 is not defined.num2 // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 1234for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。 而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。 使用let命令带来的影响1.不存在变量提升2.TDZ(暂时性死区)3.无法重复声明变量无法变量提升我们知道在javascript（ES5）中只有全局作用域和函数作用域，并不存在块级作用域，使用var命令会发生所谓的”变量提升“现象，即变量可以在声明之前使用，值为undefined。 变量提升：函数声明和变量声明总是被JavaScript解释器隐式地提升(hoist)到包含他们的作用域的最顶端。 这种变量提升会带来一些意想不到的结果，比如函数内层的变量可能会覆盖函数外层的变量，在一个循环中用来计数的循环变量泄露为全局变量。 123456789101112// var 的情况console.log(msg); // undefinedvar msg = &apos;hello&apos;;//发生了变量提升,上面的代码等价于下面的代码var msg ;console.log(msg); // msg没有赋值，输出undefinedmsg = &apos;hello&apos;;// let 的情况，暂时性死区，无法变量提升console.log(tip); // 变量tip不存在，报错，Uncaught ReferenceError: tip is not definedlet tip = &apos;ok&apos;; 12345678910var tip = &apos;success&apos;;function updateTip() &#123; console.log(tip); if (false) &#123; var tip = &apos;error&apos;; &#125;&#125;updateTip(); // undefined 上面代码的原意是，if代码块的外部使用外层的tip变量，内部使用内层的tip变量。但是，函数updateTip执行后，输出结果为undefined，原因在于变量提升，导致内层的tip变量覆盖了外层的tip变量。上面的代码等价于下面的代码： 1234567891011var tip = &apos;success&apos;;function updateTip() &#123; var tip; console.log(tip); if (false) &#123; tip = &apos;error&apos;; &#125;&#125;updateTip(); // undefined 12345678910111213var msg = &apos;hello&apos;;var msg2 =&apos;hello world&apos;;for (var i = 0; i &lt; msg.length; i++) &#123; console.log(msg[i]);&#125;console.log(i); // 5/* *中间这里省略一大段代码 **/for (; i &lt; msg2.length; i++) &#123; console.log(msg2[i]);&#125;console.log(i); // 11 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。后面还有另一个循环，循环变量同样是i，这时原本要输出的’hello world’就只输出了’world’，因为没有重新给变量赋值导致了与期待结果不一致。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 暂时性死区（temporal dead zone，简称 TDZ）：只要一进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 123456var input = 1;if (true) &#123; input = &apos;oh&apos;; // Uncaught ReferenceError: input is not defined let input;&#125; 上面代码中，存在全局变量input，但是块级作用域内let又声明了一个局部变量input，导致后者绑定这个块级作用域，所以在let声明变量前，对input赋值会报错。 123456789101112if (true) &#123; // TDZ开始 tmp = &apos;0&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // tmp变量使用let命令声明，当前作用域下该声明变量到此前的所有代码块无法赋值和使用，形成TDZ //TDZ结束 console.log(tmp); // undefined tmp = 1; console.log(tmp); // 1&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // &quot;undefined&quot; 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function a() &#123; let flag = true; var flag = false;&#125;// 报错function b() &#123; let status = &apos;ok&apos;; let status = &apos;no&apos;;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 参考资料： (阮一峰)ECMAScript 6 入门 –let 和 const 命令 更多关于ES6的知识可以去看阮一峰老师的ECMAScript 6 入门","tags":[{"name":"javascript","slug":"javascript","permalink":"chenxiaohuan.github.io/tags/javascript/"}]},{"title":"javascript老生常谈之闭包","date":"2017-04-19T06:40:13.580Z","path":"2017/04/19/closure/","text":"前文：假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类推。123456789var nodes = document.getElementsByTagName( 'div' );for(var i=0,len=nodes.length;i&lt;len;i++)&#123; nodes[ i ].onclick = function()&#123; alert(i); &#125;&#125;; 测试这段代码会发现,无论点击哪个 div,最后弹出的结果都是 5。这是因为 div 节点的 onclick 事件是被异步触发的,当事件被触发的时候,for循环早已结束,此时 i 的值已经是 5,所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时,查找到的值总是 5。解决方法是在闭包的帮助下,每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链从内到外查找变量 i 时,会先找到被封闭在闭包环境中的 i,如果有 5 个 div,这里的 i 分别 是 0,1,2,3,4123456789for(var i=0,len=nodes.length;i&lt;len;i++)&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)(i)&#125;; 当然，你也可以把循环内的变量声明关键字var改为let，不过这是es6的解决方法不在本文探讨范围内O(∩_∩)O~。 下面进入正文。 一、了解闭包须知：闭包的形成跟变量的作用域以及变量的生存周期密切相关。 变量的作用域,是指变量的有效范围。当在函数中声明一个变量的时候,如果该变量前面没有带上关键字 var,这个变量就会成为全局变量 ,这是一种很容易造成命名冲突的做法。另外一种情况是用 var 关键字在函数中声明变量,这时候的变量即是局部变量,只有在该函数内部才能访问到这个变量,在函数外面是访问不到的。 变量的搜索是从内到外而非从外到内的。当函数被调用时： 先创建一个执行环境(execution context),及相应的作用域链； 将arguments和其他命名参数的值添加到函数的活动对象(activation object) 作用域链：当前函数的活动对象优先级最高，外部函数的活动对象次之，外部函数的外部函数的活动对象依次递减，直至作用域链的末端–全局作用域。优先级就是变量查找的先后顺序。 你可以在Chrome浏览器Console控制台运行下面的代码看看运行结果。 12345678910var func=function()&#123; var msg = \"hello\"; console.log(msg); //输出:hello &#125;;func();console.log ( msg ); // Uncaught ReferenceError: msg is not defined 12345678910111213141516var num1 = 1;var func1 = function()&#123; var num2 = 2; var func2 = function()&#123; var num3 = 3; console.log ( num1 ); // 输出:1 console.log ( num2 );// 输出:2 &#125; func2(); console.log( num3 );//输出:Uncaught ReferenceError: num3 is not defined&#125;; func1(); 对于全局变量来说,全局变量的生存周期当然是的永久,除非我们主动销毁这个全局变量。而对于在函数内用 var 关键字声明的局部变量来说,当退出函数时,这些局部变量即失去了 它们的价值,它们都会随着函数的调用的结束而销毁。 二.什么是闭包闭包是指有权访问另一个函数作用域中变量的函数 –《JS高级程序设计第三版》函数对象可以通过作用域链相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为 ‘闭包’ 。 –《JS权威指南》内部函数可以访问定义它们的外部函数的参数和变量(除了this和arguments)。 –《JS语言精粹》 根据上面的描述我们来创建个简单的闭包：123456789101112var sayName = function() &#123; var name = 'shana'; return function() &#123; alert(name); &#125;&#125;;var say = sayName(); say(); 上面的例子简单说明一下：var say = sayName() ：返回了一个匿名的内部函数保存在变量say中，并且引用了外部函数的变量name，由于垃圾回收机制，sayName函数执行完毕后，变量name并没有被销毁。 say() ：执行返回的内部函数，依然能访问变量name,输出 ‘shana’ . 三.为什么使用闭包1.封装变量—-闭包可以帮助一些不需要暴露在全局的变量封装成“私有变量”。2.延长变量的生存周期，可以让一个变量常驻内存。3.避免全局变量的污染。 123456789101112131415var add = (function() &#123; var num = 0; return function() &#123; num++; console.log(num); &#125;&#125;)();console.log(num); //undefinedadd();add(); 四.使用闭包需要注意的一些问题1.因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。2.使用闭包要小心循环引用，不要造成死循环，引起内存泄露。举个例子：A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。 五.补充：内存泄露及解决方案 说到内存管理，自然离不开JS中的垃圾回收机制，有两种策略来实现垃圾回收：标记清除 和 引用计数； 标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 2008年为止，IE，Firefox，opera，chrome，Safari的javascript都用使用了该方式； 引用计数：跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个值的引用次数就是1，如果这个值再被赋值给另一个变量，则引用次数加1。相反，如果一个变量脱离了该值的引用，则该值引用次数减1，当次数为0时，就会等待垃圾收集器的回收。 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。早期的IE版本里（ie4-ie6）采用是计数的垃圾回收机制，闭包导致内存泄露的一个原因就是这个算法的一个缺陷。 我们知道，IE中有一部分对象并不是原生额javascript对象，例如，BOM和DOM中的对象就是以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数。因此，虽然IE的javascript引擎采用的是标记清除策略，但是访问COM对象依然是基于引用计数的，因此只要在IE中设计COM对象就会存在循环引用的问题！ 举个栗子：12345678window.onload = function()&#123; var el = document.getElementById(\"id\"); el.onclick = function()&#123; alert(el.id); &#125;&#125; 这段代码为什么会造成内存泄露？12345el.onclick= function () &#123; alert(el.id);&#125;; 执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收； 解决方法：12345678910window.onload = function()&#123; var el = document.getElementById(\"id\"); var id = el.id; //解除循环引用 el.onclick = function()&#123; alert(id); &#125; el = null; // 将闭包引用的外部函数中活动对象清除&#125; 到此本文结束，如果还有什么疑问或者建议，可以多多交流。","tags":[{"name":"javascript","slug":"javascript","permalink":"chenxiaohuan.github.io/tags/javascript/"}]}]