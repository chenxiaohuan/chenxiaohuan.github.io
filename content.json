[{"title":"es6之关键字let","date":"2017-04-25T08:14:07.710Z","path":"2017/04/25/es6-let-command/index.html","text":"前文：在前面闭包一文有提到： 假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类推。 我们用闭包实现了这个效果，同时我们提到了可以使用es6的let命令实现一样的效果。所以本文将介绍一下es6的let命令。 什么是let命令let命令是ES6新增的关键字，它用来声明变量。用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let num1 = 0; var num2 = 1;&#125;num1 // ReferenceError: num1 is not defined.num2 // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 1234for (let i = 0; i &lt; 10; i++) &#123;&#125;console.log(i);//ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的function在运行时，会通过闭包读到这同一个变量i，导致最后输出的是最后一轮的i的值，也就是10。 而如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是循环语句部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc 上面代码输出了3次abc，这表明函数内部的变量i和外部的变量i是分离的。 使用let命令带来的影响1.不存在变量提升2.TDZ(暂时性死区)3.无法重复声明变量无法变量提升我们知道在javascript（ES5）中只有全局作用域和函数作用域，并不存在块级作用域，使用var命令会发生所谓的”变量提升“现象，即变量可以在声明之前使用，值为undefined。 变量提升：函数声明和变量声明总是被JavaScript解释器隐式地提升(hoist)到包含他们的作用域的最顶端。 这种变量提升会带来一些意想不到的结果，比如函数内层的变量可能会覆盖函数外层的变量，在一个循环中用来计数的循环变量泄露为全局变量。 123456789101112// var 的情况console.log(msg); // undefinedvar msg = &apos;hello&apos;;//发生了变量提升,上面的代码等价于下面的代码var msg ;console.log(msg); // msg没有赋值，输出undefinedmsg = &apos;hello&apos;;// let 的情况，暂时性死区，无法变量提升console.log(tip); // 变量tip不存在，报错，Uncaught ReferenceError: tip is not definedlet tip = &apos;ok&apos;; 12345678910var tip = &apos;success&apos;;function updateTip() &#123; console.log(tip); if (false) &#123; var tip = &apos;error&apos;; &#125;&#125;updateTip(); // undefined 上面代码的原意是，if代码块的外部使用外层的tip变量，内部使用内层的tip变量。但是，函数updateTip执行后，输出结果为undefined，原因在于变量提升，导致内层的tip变量覆盖了外层的tip变量。上面的代码等价于下面的代码： 1234567891011var tip = &apos;success&apos;;function updateTip() &#123; var tip; console.log(tip); if (false) &#123; tip = &apos;error&apos;; &#125;&#125;updateTip(); // undefined 12345678910111213var msg = &apos;hello&apos;;var msg2 =&apos;hello world&apos;;for (var i = 0; i &lt; msg.length; i++) &#123; console.log(msg[i]);&#125;console.log(i); // 5/* *中间这里省略一大段代码 **/for (; i &lt; msg2.length; i++) &#123; console.log(msg2[i]);&#125;console.log(i); // 11 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。后面还有另一个循环，循环变量同样是i，这时原本要输出的’hello world’就只输出了’world’，因为没有重新给变量赋值导致了与期待结果不一致。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 暂时性死区（temporal dead zone，简称 TDZ）：只要一进入当前作用域，所要使用的变量就已经存在，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 123456var input = 1;if (true) &#123; input = &apos;oh&apos;; // Uncaught ReferenceError: input is not defined let input;&#125; 上面代码中，存在全局变量input，但是块级作用域内let又声明了一个局部变量input，导致后者绑定这个块级作用域，所以在let声明变量前，对input赋值会报错。 123456789101112if (true) &#123; // TDZ开始 tmp = &apos;0&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // tmp变量使用let命令声明，当前作用域下该声明变量到此前的所有代码块无法赋值和使用，形成TDZ //TDZ结束 console.log(tmp); // undefined tmp = 1; console.log(tmp); // 1&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // &quot;undefined&quot; 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function a() &#123; let flag = true; var flag = false;&#125;// 报错function b() &#123; let status = &apos;ok&apos;; let status = &apos;no&apos;;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 参考资料： (阮一峰)ECMAScript 6 入门 –let 和 const 命令 更多关于ES6的知识可以去看阮一峰老师的ECMAScript 6 入门","tags":[]},{"title":"javascript老生常谈之闭包","date":"2017-04-19T06:40:13.580Z","path":"2017/04/19/closure/index.html","text":"前文：假设页面上有 5 个 div 节点,我们通过循环来给每个 div绑定 onclick 事件,按照索引顺序,点击第 1 个 div 时弹出 0,点击第 2 个 div 时出 1,以此类推。123456789var nodes = document.getElementsByTagName( 'div' );for(var i=0,len=nodes.length;i&lt;len;i++)&#123; nodes[ i ].onclick = function()&#123; alert(i); &#125;&#125;; 测试这段代码会发现,无论点击哪个 div,最后弹出的结果都是 5。这是因为 div 节点的 onclick 事件是被异步触发的,当事件被触发的时候,for循环早已结束,此时 i 的值已经是 5,所以在 div 的 onclick 事件函数中顺着作用域链从内到外查找变量 i 时,查找到的值总是 5。解决方法是在闭包的帮助下,每次循环的 i 值都封闭起来。当在事件函数中顺着作用域链从内到外查找变量 i 时,会先找到被封闭在闭包环境中的 i,如果有 5 个 div,这里的 i 分别 是 0,1,2,3,4123456789for(var i=0,len=nodes.length;i&lt;len;i++)&#123; (function( i )&#123; nodes[ i ].onclick = function()&#123; console.log(i); &#125; &#125;)(i)&#125;; 当然，你也可以把循环内的变量声明关键字var改为let，不过这是es6的解决方法不在本文探讨范围内O(∩_∩)O~。 下面进入正文。 一、了解闭包须知：闭包的形成跟变量的作用域以及变量的生存周期密切相关。 变量的作用域,是指变量的有效范围。当在函数中声明一个变量的时候,如果该变量前面没有带上关键字 var,这个变量就会成为全局变量 ,这是一种很容易造成命名冲突的做法。另外一种情况是用 var 关键字在函数中声明变量,这时候的变量即是局部变量,只有在该函数内部才能访问到这个变量,在函数外面是访问不到的。 变量的搜索是从内到外而非从外到内的。当函数被调用时： 先创建一个执行环境(execution context),及相应的作用域链； 将arguments和其他命名参数的值添加到函数的活动对象(activation object) 作用域链：当前函数的活动对象优先级最高，外部函数的活动对象次之，外部函数的外部函数的活动对象依次递减，直至作用域链的末端–全局作用域。优先级就是变量查找的先后顺序。 你可以在Chrome浏览器Console控制台运行下面的代码看看运行结果。 12345678910var func=function()&#123; var msg = \"hello\"; console.log(msg); //输出:hello &#125;;func();console.log ( msg ); // Uncaught ReferenceError: msg is not defined 12345678910111213141516var num1 = 1;var func1 = function()&#123; var num2 = 2; var func2 = function()&#123; var num3 = 3; console.log ( num1 ); // 输出:1 console.log ( num2 );// 输出:2 &#125; func2(); console.log( num3 );//输出:Uncaught ReferenceError: num3 is not defined&#125;; func1(); 对于全局变量来说,全局变量的生存周期当然是的永久,除非我们主动销毁这个全局变量。而对于在函数内用 var 关键字声明的局部变量来说,当退出函数时,这些局部变量即失去了 它们的价值,它们都会随着函数的调用的结束而销毁。 二.什么是闭包闭包是指有权访问另一个函数作用域中变量的函数 –《JS高级程序设计第三版》函数对象可以通过作用域链相关联起来，函数体内部的变量都可以保存在函数作用域内，这种特性称为 ‘闭包’ 。 –《JS权威指南》内部函数可以访问定义它们的外部函数的参数和变量(除了this和arguments)。 –《JS语言精粹》 根据上面的描述我们来创建个简单的闭包：123456789101112var sayName = function() &#123; var name = 'shana'; return function() &#123; alert(name); &#125;&#125;;var say = sayName(); say(); 上面的例子简单说明一下：var say = sayName() ：返回了一个匿名的内部函数保存在变量say中，并且引用了外部函数的变量name，由于垃圾回收机制，sayName函数执行完毕后，变量name并没有被销毁。 say() ：执行返回的内部函数，依然能访问变量name,输出 ‘shana’ . 三.为什么使用闭包1.封装变量—-闭包可以帮助一些不需要暴露在全局的变量封装成“私有变量”。2.延长变量的生存周期，可以让一个变量常驻内存。3.避免全局变量的污染。 123456789101112131415var add = (function() &#123; var num = 0; return function() &#123; num++; console.log(num); &#125;&#125;)();console.log(num); //undefinedadd();add(); 四.使用闭包需要注意的一些问题1.因为闭包会携带包含它的函数的作用域，因此会比其他函数占用更多的内存。2.使用闭包要小心循环引用，不要造成死循环，引起内存泄露。举个例子：A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。 五.补充：内存泄露及解决方案 说到内存管理，自然离不开JS中的垃圾回收机制，有两种策略来实现垃圾回收：标记清除 和 引用计数； 标记清除：垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记，然后，它会去掉环境中的变量的标记和被环境中的变量引用的变量的标记，此后，如果变量再被标记则表示此变量准备被删除。 2008年为止，IE，Firefox，opera，chrome，Safari的javascript都用使用了该方式； 引用计数：跟踪记录每个值被引用的次数，当声明一个变量并将一个引用类型的值赋给该变量时，这个值的引用次数就是1，如果这个值再被赋值给另一个变量，则引用次数加1。相反，如果一个变量脱离了该值的引用，则该值引用次数减1，当次数为0时，就会等待垃圾收集器的回收。 这个方式存在一个比较大的问题就是循环引用，就是说A对象包含一个指向B的指针，对象B也包含一个指向A的引用。 这就可能造成大量内存得不到回收（内存泄露），因为它们的引用次数永远不可能是 0 。早期的IE版本里（ie4-ie6）采用是计数的垃圾回收机制，闭包导致内存泄露的一个原因就是这个算法的一个缺陷。 我们知道，IE中有一部分对象并不是原生额javascript对象，例如，BOM和DOM中的对象就是以COM对象的形式实现的，而COM对象的垃圾回收机制采用的就是引用计数。因此，虽然IE的javascript引擎采用的是标记清除策略，但是访问COM对象依然是基于引用计数的，因此只要在IE中设计COM对象就会存在循环引用的问题！ 举个栗子：12345678window.onload = function()&#123; var el = document.getElementById(\"id\"); el.onclick = function()&#123; alert(el.id); &#125;&#125; 这段代码为什么会造成内存泄露？12345el.onclick= function () &#123; alert(el.id);&#125;; 执行这段代码的时候，将匿名函数对象赋值给el的onclick属性；然后匿名函数内部又引用了el对象，存在循环引用，所以不能被回收； 解决方法：12345678910window.onload = function()&#123; var el = document.getElementById(\"id\"); var id = el.id; //解除循环引用 el.onclick = function()&#123; alert(id); &#125; el = null; // 将闭包引用的外部函数中活动对象清除&#125; 到此本文结束，如果还有什么疑问或者建议，可以多多交流。","tags":[]}]